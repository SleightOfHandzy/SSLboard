# SSLboard
Rutgers CS 419 OpenSSL Message Board Project

## Overview

We designed our project from the ground up, beginning with a simple client/server program, adding multithreading functionality, and slowly adding SSL certificates and end-to-end encryption.

We chose to use Go, a relatively new language that simplified a lot of C functionality, making it easier to implement a lot of the features required for this project. We used the `crypto/tls` package in Go for any SSL/TLS functions (certificates, TLS handshakes, etc.).

## Installation

In order to install Go, you must install the appropriate package from the following link:

    https://golang.org/dl/

Then, you need to place the source directory (.../SSLboard/) in ~/go/src/github.com/SleightOfHandzy/ to create a relative pathname of: 

    ~/go/src/github.com/SleightOfHandzy/SSLboard/...
    
From this point forward, you will be able to cd into a directory, compile, and execute our project.

## Packages

The external packages we used in this project include:

    google.golang.org/grpc
    google.golang.org/grpc/credentials
    golang.org/x/crypto/ssh/terminal
    golang.org/x/crypto/bcrypt
    github.com/golang/protobuf
    github.com/boltdb/bolt

We use grpc (Google's Remote Procedure Calls) to simplify the interaction between the client and the server.
We use grpc/credentials to create transport credentials based on TLS. 
We use crypto/ssh/terminal to securely read passwords from the command line (not showing pwd characters == 'securely')
We use crypto/bcrypt for salting and hashing our passwords.
We use github.com/golang/protobuf and a .proto file to implement our grpc service, which is compiled with the command 'protoc'.
We use github.com/boltdb/bolt as a back-end database, a key-value pair which uses 'buckets' for organization.

## Design

First, we implemented a simple client/server model in Go, using TLS sockets and openSSL to generate a certificate and a key. Then, we added GRPC functionality to simplify remote calls and eliminate parsing using delimiters (which could appear in a command, group name, message, and break our code). Once we had the basic structures set up, we added input via terminal: (username, password) verification, accepting a command (<CMD> <GRP> <MSG>), parsed that command, and sent a corresponding RPC to the correct server-side function in /server/service.go. 
  
We used the structs auto-generated by 'protoc' (Message and Credentials structs) to send our complex messages over the pipe. You can directly view the result of the /pb/SSLboard.proto compilation in /pb/SSLboard.pb.go. This eliminated the need for delimitation and Read/Write calls over the TLS socket.

Then, we implemented our database to handle all calls for GET and POST. We store username-sessionTokenID as key-value pairs to validate that an RPC is being called by an authenticated (logged-in) user. If the database fails to find a match, the RPC was made by a non-authenticated user. We use a separate bucket (group) for each group name. If the bucket does not exist, the group does not exist. 

With GET calls, our service fetches all known messages in a certain group (bucket) and returns them to the client to quickly output to the terminal. If the <GRP> specified does not exist, an error will be returned.

With POST calls, our service opens a bucket to the <GRP> specified in the command arguments (error on non-existent bucket), and then appends the message to the end of the bucket. On success, a success message will be returned, and on a non-existent group name, an error will be returned.

#### GRPC

We setup a service, outlined in server/service.go, to handle remote calls. In server.go, we have a main method that initiates a grpc service and then calls Serve(), which allows the grpc module to activate and handle requests. Client-side, we open a connection to the corresponding grpc server, and get handed back an object which allows us to make 'local calls' on the struct, which are interpreted by grpc and handed to the service to execute.

## Challenges

#### Learning Golang (Go)

To accomplish this project, our entire team needed to learn Go from scratch. None of our members had any real prior exposure or experience with this language, however we started early and this allowed us to explore many options and truly see the power of the Go library and external packages.

#### User Session Tokens

Since we were using RPC's, theoretically, any connected (via grpc.Dial() call) user could make RPC's to our service. Thus, we needed to create a list of unique user session ID tokens, stored in the bolt database. 

#### GRPC

Learning grpc was a bit of a challenge, especially figuring out how we would implement the compiled .go file (compiled from .proto file). However, after a fair bit of research and testing, we were able to successfully implement RPC's which made sending information (credentials, messages, anything) over the TLS pipe trivial.

#### protobuffers

Learning how to write a .proto file was rather easy, as we only had to define a few methods that we were to implement along with the necessary structs to send information over our connection. 

#### dep (ensure)

dep allowed us to bundle all external dependencies (the not-standard Go packages) and export them with our project. This offers an extremely large convinience to us, and to whoever is running our project by not requiring the executor to "go get" (command-line tool for downloading Go packages) any external packages.

## Solutions

## Testing

We successfully tested the following mandatory events:

- [x] Server can accept multiple clients
- [ ] Trying to fetch messages from a group that doesnâ€™t exist
- [ ] Trying to provide an invalid username/password combo
- [ ] Attempting to submit blank messages or invalid group names
- [ ] Client cannot access private key, certificate, or password file

We also successfully tested for our own purposes:

- [ ] Custom Test 1
- [ ] Custom Test 2
- [ ] Custom Test 3... etc

## Notes

We used following commands for key and certificate generation

```sh
openssl genrsa -out server.key 2048
openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650
```
